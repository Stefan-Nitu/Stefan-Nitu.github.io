<!DOCTYPE html><html lang="en"><head>
    <meta charset="utf-8">
    <title>Swift.org - API Design Guidelines</title>
    
    <meta name="author" content="Apple Inc.">
    <meta name="viewport" content="width=device-width initial-scale=1">
    
    <link rel="license" href="/LICENSE.txt">
    <link rel="stylesheet" media="all" href="css/application.css">
</head>

<body>

<script src="js/color-scheme-toggle.js"></script>

<main role="main">
    <article class="page">
            <header>
                <h1 id="swift-api-style-guidelines">API Design Guidelines</h1>
            </header>
<style>
article pre {
        overflow: visible;
}
</style>

<h2 class="no_toc" id="table-of-contents">Table of Contents</h2>

<ul id="markdown-toc">
    <li><a href="#introduction" id="markdown-toc-introduction">Introduction</a></li>
    <li><a href="#fundamentals" id="markdown-toc-fundamentals">Fundamentals</a></li>
    <li><a href="#naming" id="markdown-toc-naming">Naming</a>    <ul>
            <li><a href="#promote-clear-usage" id="markdown-toc-promote-clear-usage">Promote Clear Usage</a></li>
            <li><a href="#strive-for-fluent-usage" id="markdown-toc-strive-for-fluent-usage">Strive for Fluent Usage</a></li>
            <li><a href="#use-terminology-well" id="markdown-toc-use-terminology-well">Use Terminology Well</a></li>
        </ul>
    </li>
    <li><a href="#conventions" id="markdown-toc-conventions">Conventions</a>    <ul>
            <li><a href="#general-conventions" id="markdown-toc-general-conventions">General Conventions</a></li>
            <li><a href="#parameter-names" id="markdown-toc-parameter-names">Parameters</a></li>
            <li><a href="#argument-labels" id="markdown-toc-argument-labels">Argument Labels</a></li>
        </ul>
    </li>
    <li><a href="#special-instructions" id="markdown-toc-special-instructions">Special Instructions</a></li>
</ul>

<h2 id="introduction">Introduction</h2>

<p>Delivering a clear, consistent developer experience when writing Swift code is largely defined by the names and idioms that appear in APIs.
These design guidelines explain how to make sure that your code feels like a part of the larger Swift ecosystem.</p>

<h2 id="fundamentals">Fundamentals</h2>

<ul>
    <li>
        <p id="clarity-at-the-point-of-use"><strong>Clarity at the point of use</strong> is your most important goal.
Entities such as methods and properties are declared only once but
<em>used</em> repeatedly.  Design APIs to make those uses clear and
concise.  When evaluating a design, reading a declaration is seldom
sufficient; always examine a use case to make sure it looks
clear in context.</p>
    </li>
    <li>
        <p id="clarity-over-brevity"><strong>Clarity is more important than brevity.</strong>  Although Swift
code can be compact, it is a <em>non-goal</em>
to enable the smallest possible code with the fewest characters.
Brevity in Swift code, where it occurs, is a side-effect of the
strong type system and features that naturally reduce boilerplate.</p>
    </li>
    <li>
        <p id="write-doc-comment"><strong>Write a documentation comment</strong>
for every declaration. Insights gained by writing documentation can
have a profound impact on your design, so don’t put it off.</p>

        <div class="warning">
            <p>If you are having trouble describing your API’s
functionality in simple terms, <strong>you may have designed the wrong API.</strong></p>
        </div>

        <div class="more">

            <ul>
                <li>
                    <p><strong>Use Swift’s <a href="https://developer.apple.com/library/prerelease/mac/documentation/Xcode/Reference/xcode_markup_formatting_ref/">dialect of Markdown</a>.</strong></p>
                </li>
                <li>
                    <p><strong>Begin with a summary</strong> that describes the entity being declared.
Often, an API can be completely understood from its declaration and
its summary.</p>

                    <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/// <strong>Returns a "view" of `self` containing the same elements in</strong>
/// <strong>reverse order.</strong>
func reversed() -&gt; ReverseCollection<self>
</self></code></pre></div>          </div>

                    <div class="more">

                        <ul>
                            <li>
                                <p><strong>Focus on the summary</strong>; it’s the most important part. Many
excellent documentation comments consist of nothing more than a
great summary.</p>
                            </li>
                            <li>
                                <p><strong>Use a single sentence fragment</strong> if possible, ending with a
period.  Do not use a complete sentence.</p>
                            </li>
                            <li>
                                <p><strong>Describe what a function or method <em>does</em> and what it
<em>returns</em></strong>, omitting null effects and <code class="language-plaintext highlighter-rouge">Void</code> returns:</p>

                                <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/// <strong>Inserts</strong> `newHead` at the beginning of `self`.
mutating func prepend(_ newHead: Int)

/// <strong>Returns</strong> a `List` containing `head` followed by the elements
/// of `self`.
func prepending(_ head: Element) -&gt; List

/// <strong>Removes and returns</strong> the first element of `self` if non-empty;
/// returns `nil` otherwise.
mutating func popFirst() -&gt; Element?
</code></pre></div>                </div>

                                <p>Note: in rare cases like <code class="language-plaintext highlighter-rouge">popFirst</code> above, the summary is formed
of multiple sentence fragments separated by semicolons.</p>
                            </li>
                            <li>
                                <p><strong>Describe what a subscript <em>accesses</em></strong>:</p>

                                <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/// <strong>Accesses</strong> the `index`th element.
subscript(index: Int) -&gt; Element { get set }
</code></pre></div>                </div>
                            </li>
                            <li>
                                <p><strong>Describe what an initializer <em>creates</em></strong>:</p>

                                <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/// <strong>Creates</strong> an instance containing `n` repetitions of `x`.
init(count n: Int, repeatedElement x: Element)
</code></pre></div>                </div>
                            </li>
                            <li>
                                <p>For all other declarations, <strong>describe what the declared entity <em>is</em></strong>.</p>

                                <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/// <strong>A collection that</strong> supports equally efficient insertion/removal
/// at any position.
struct List {

    /// <strong>The element at the beginning</strong> of `self`, or `nil` if self is
    /// empty.
    var first: Element?
    ...
</code></pre></div>                </div>
                            </li>
                        </ul>

                    </div>
                </li>
                <li>
                    <p><strong>Optionally, continue</strong> with one or more paragraphs and bullet
items.  Paragraphs are separated by blank lines and use complete
sentences.</p>

                    <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/// Writes the textual representation of each    <span class="graphic">←</span><span class="commentary"> Summary</span>
/// element of `items` to the standard output.
///                                              <span class="graphic">←</span><span class="commentary"> Blank line</span>
/// The textual representation for each item `x` <span class="graphic">←</span><span class="commentary"> Additional discussion</span>
/// is generated by the expression `String(x)`.
///
/// - <strong>Parameter separator</strong>: text to be printed    <span class="graphic">⎫</span>
///   between items.                             <span class="graphic">⎟</span>
/// - <strong>Parameter terminator</strong>: text to be printed   <span class="graphic">⎬</span><span class="commentary"> <a href="https://developer.apple.com/library/prerelease/mac/documentation/Xcode/Reference/xcode_markup_formatting_ref/SymbolDocumentation.html#//apple_ref/doc/uid/TP40016497-CH51-SW14">Parameters section</a></span>
///   at the end.                                <span class="graphic">⎟</span>
///                                              <span class="graphic">⎭</span>
/// - <strong>Note</strong>: To print without a trailing          <span class="graphic">⎫</span>
///   newline, pass `terminator: ""`             <span class="graphic">⎟</span>
///                                              <span class="graphic">⎬</span><span class="commentary"> <a href="https://developer.apple.com/library/prerelease/mac/documentation/Xcode/Reference/xcode_markup_formatting_ref/SymbolDocumentation.html#//apple_ref/doc/uid/TP40016497-CH51-SW13">Symbol commands</a></span>
/// - <strong>SeeAlso</strong>: `CustomDebugStringConvertible`,   <span class="graphic">⎟</span>
///   `CustomStringConvertible`, `debugPrint`.   <span class="graphic">⎭</span>
public func print<target: outputstreamtype="">(
    _ items: Any..., separator: String = " ", terminator: String = "\n")
</target:></code></pre></div>          </div>

                    <div class="more">

                        <ul>
                            <li>
                                <p><strong>Use recognized
<a href="https://developer.apple.com/library/prerelease/mac/documentation/Xcode/Reference/xcode_markup_formatting_ref/SymbolDocumentation.html#//apple_ref/doc/uid/TP40016497-CH51-SW1">symbol documentation markup</a>
elements</strong> to add information beyond the summary, whenever
appropriate.</p>
                            </li>
                            <li>
                                <p><strong>Know and use recognized bullet items with
<a href="https://developer.apple.com/library/prerelease/mac/documentation/Xcode/Reference/xcode_markup_formatting_ref/SymbolDocumentation.html#//apple_ref/doc/uid/TP40016497-CH51-SW13">symbol command syntax</a>.</strong> Popular development
tools such as Xcode give special treatment to bullet items that
start with the following keywords:</p>

                                <table>
                                    <tbody>
                                        <tr>
                                            <td><a href="https://developer.apple.com/library/prerelease/mac/documentation/Xcode/Reference/xcode_markup_formatting_ref/Attention.html">Attention</a></td>
                                            <td><a href="https://developer.apple.com/library/prerelease/mac/documentation/Xcode/Reference/xcode_markup_formatting_ref/Author.html">Author</a></td>
                                            <td><a href="https://developer.apple.com/library/prerelease/mac/documentation/Xcode/Reference/xcode_markup_formatting_ref/Authors.html">Authors</a></td>
                                            <td><a href="https://developer.apple.com/library/prerelease/mac/documentation/Xcode/Reference/xcode_markup_formatting_ref/Bug.html">Bug</a></td>
                                        </tr>
                                        <tr>
                                            <td><a href="https://developer.apple.com/library/prerelease/mac/documentation/Xcode/Reference/xcode_markup_formatting_ref/Complexity.html">Complexity</a></td>
                                            <td><a href="https://developer.apple.com/library/prerelease/mac/documentation/Xcode/Reference/xcode_markup_formatting_ref/Copyright.html">Copyright</a></td>
                                            <td><a href="https://developer.apple.com/library/prerelease/mac/documentation/Xcode/Reference/xcode_markup_formatting_ref/Date.html">Date</a></td>
                                            <td><a href="https://developer.apple.com/library/prerelease/mac/documentation/Xcode/Reference/xcode_markup_formatting_ref/Experiment.html">Experiment</a></td>
                                        </tr>
                                        <tr>
                                            <td><a href="https://developer.apple.com/library/prerelease/mac/documentation/Xcode/Reference/xcode_markup_formatting_ref/Important.html">Important</a></td>
                                            <td><a href="https://developer.apple.com/library/prerelease/mac/documentation/Xcode/Reference/xcode_markup_formatting_ref/Invariant.html">Invariant</a></td>
                                            <td><a href="https://developer.apple.com/library/prerelease/mac/documentation/Xcode/Reference/xcode_markup_formatting_ref/Note.html">Note</a></td>
                                            <td><a href="https://developer.apple.com/library/prerelease/mac/documentation/Xcode/Reference/xcode_markup_formatting_ref/Parameter.html">Parameter</a></td>
                                        </tr>
                                        <tr>
                                            <td><a href="https://developer.apple.com/library/prerelease/mac/documentation/Xcode/Reference/xcode_markup_formatting_ref/Parameters.html">Parameters</a></td>
                                            <td><a href="https://developer.apple.com/library/prerelease/mac/documentation/Xcode/Reference/xcode_markup_formatting_ref/Postcondition.html">Postcondition</a></td>
                                            <td><a href="https://developer.apple.com/library/prerelease/mac/documentation/Xcode/Reference/xcode_markup_formatting_ref/Precondition.html">Precondition</a></td>
                                            <td><a href="https://developer.apple.com/library/prerelease/mac/documentation/Xcode/Reference/xcode_markup_formatting_ref/Remark.html">Remark</a></td>
                                        </tr>
                                        <tr>
                                            <td><a href="https://developer.apple.com/library/prerelease/mac/documentation/Xcode/Reference/xcode_markup_formatting_ref/Requires.html">Requires</a></td>
                                            <td><a href="https://developer.apple.com/library/prerelease/mac/documentation/Xcode/Reference/xcode_markup_formatting_ref/Returns.html">Returns</a></td>
                                            <td><a href="https://developer.apple.com/library/prerelease/mac/documentation/Xcode/Reference/xcode_markup_formatting_ref/SeeAlso.html">SeeAlso</a></td>
                                            <td><a href="https://developer.apple.com/library/prerelease/mac/documentation/Xcode/Reference/xcode_markup_formatting_ref/Since.html">Since</a></td>
                                        </tr>
                                        <tr>
                                            <td><a href="https://developer.apple.com/library/prerelease/mac/documentation/Xcode/Reference/xcode_markup_formatting_ref/Throws.html">Throws</a></td>
                                            <td><a href="https://developer.apple.com/library/prerelease/mac/documentation/Xcode/Reference/xcode_markup_formatting_ref/Todo.html">ToDo</a></td>
                                            <td><a href="https://developer.apple.com/library/prerelease/mac/documentation/Xcode/Reference/xcode_markup_formatting_ref/Version.html">Version</a></td>
                                            <td><a href="https://developer.apple.com/library/prerelease/mac/documentation/Xcode/Reference/xcode_markup_formatting_ref/Warning.html">Warning</a></td>
                                        </tr>
                                    </tbody>
                                </table>
                            </li>
                        </ul>

                    </div>
                </li>
            </ul>

        </div>
    </li>
</ul>

<h2 id="naming">Naming</h2>

<h3 id="promote-clear-usage">Promote Clear Usage</h3>

<ul>
    <li>
        <p id="include-words-to-avoid-ambiguity"><strong>Include all the words needed to avoid ambiguity</strong> for a person
reading code where the name is used.</p>

        <div class="more">
            <p>For example, consider a method that removes the element at a
given position within a collection.</p>

            <div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code>extension List {
    public mutating func remove(at position: Index) -&gt; Element
}
employees.remove(at: x)
</code></pre></div>      </div>

            <p>If we were to omit the word <code class="language-plaintext highlighter-rouge">at</code> from the method signature, it could
imply to the reader that the method searches for and removes an
element equal to <code class="language-plaintext highlighter-rouge">x</code>, rather than using <code class="language-plaintext highlighter-rouge">x</code> to indicate the
position of the element to remove.</p>

            <div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code>employees.remove(x) // unclear: are we removing x?
</code></pre></div>      </div>

        </div>
    </li>
    <li>
        <p id="omit-needless-words"><strong>Omit needless words.</strong> Every word in a name should convey salient
information at the use site.</p>

        <div class="more">
            <p>More words may be needed to clarify intent or disambiguate
meaning, but those that are redundant with information the reader
already possesses should be omitted. In particular, omit words that
<em>merely repeat</em> type information.</p>

            <div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public mutating func removeElement(_ member: Element) -&gt; Element?

allViews.removeElement(cancelButton)
</code></pre></div>      </div>

            <p>In this case, the word <code class="language-plaintext highlighter-rouge">Element</code> adds nothing salient at the call
site. This API would be better:</p>

            <div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public mutating func remove(_ member: Element) -&gt; Element?

allViews.remove(cancelButton) // clearer
</code></pre></div>      </div>

            <p>Occasionally, repeating type information is necessary to avoid
ambiguity, but in general it is better to use a word that
describes a parameter’s <em>role</em> rather than its type. See the next
item for details.</p>
        </div>
    </li>
    <li>
        <p id="name-according-to-roles"><strong>Name variables, parameters, and associated types according to
their roles,</strong> rather than their type constraints.</p>

        <div class="more">
            <div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var <strong>string</strong> = "Hello"
protocol ViewController {
    associatedtype <strong>View</strong>Type : View
}
class ProductionLine {
    func restock(from <strong>widgetFactory</strong>: WidgetFactory)
}
</code></pre></div>      </div>

            <p>Repurposing a type name in this way fails to optimize clarity and
expressivity. Instead, strive to choose a name that expresses the
entity’s <em>role</em>.</p>

            <div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var <strong>greeting</strong> = "Hello"
protocol ViewController {
    associatedtype <strong>ContentView</strong> : View
}
class ProductionLine {
    func restock(from <strong>supplier</strong>: WidgetFactory)
}
</code></pre></div>      </div>

            <p>If an associated type is so tightly bound to its protocol constraint
that the protocol name <em>is</em> the role, avoid collision by appending
<code class="language-plaintext highlighter-rouge">Protocol</code> to the protocol name:</p>

            <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code>protocol Sequence {
    associatedtype Iterator : Iterator<strong>Protocol</strong>
}
protocol Iterator<strong>Protocol</strong> { ... }
</code></pre></div>      </div>
        </div>
    </li>
    <li>
        <p id="weak-type-information"><strong>Compensate for weak type information</strong> to clarify a parameter’s role.</p>

        <div class="more">
            <p>Especially when a parameter type is <code class="language-plaintext highlighter-rouge">NSObject</code>, <code class="language-plaintext highlighter-rouge">Any</code>, <code class="language-plaintext highlighter-rouge">AnyObject</code>,
or a fundamental type such as <code class="language-plaintext highlighter-rouge">Int</code> or <code class="language-plaintext highlighter-rouge">String</code>, type information and
context at the point of use may not fully convey intent. In this
example, the declaration may be clear, but the use site is vague.</p>

            <div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code>func add(_ observer: NSObject, for keyPath: String)

grid.add(self, for: graphics) // vague
</code></pre></div>      </div>

            <p>To restore clarity, <strong>precede each weakly typed parameter with a
noun describing its role</strong>:</p>

            <div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code>func add<strong>Observer</strong>(_ observer: NSObject, for<strong>KeyPath</strong> path: String)
grid.addObserver(self, forKeyPath: graphics) // clear
</code></pre></div>      </div>
        </div>
    </li>
</ul>

<h3 id="strive-for-fluent-usage">Strive for Fluent Usage</h3>

<ul>
    <li>
        <p id="methods-and-functions-read-as-phrases"><strong>Prefer method and function names that make use sites form
grammatical English phrases.</strong></p>

        <div class="more">
            <div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code>x.insert(y, at: z)          <span class="commentary">“x, insert y at z”</span>
x.subViews(havingColor: y)  <span class="commentary">“x's subviews having color y”</span>
x.capitalizingNouns()       <span class="commentary">“x, capitalizing nouns”</span>
</code></pre></div>      </div>

            <div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code>x.insert(y, position: z)
x.subViews(color: y)
x.nounCapitalize()
</code></pre></div>      </div>

            <p>It is acceptable for fluency to degrade after the first argument or
two when those arguments are not central to the call’s meaning:</p>

            <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code>AudioUnit.instantiate(
    with: description,
    <strong>options: [.inProcess], completionHandler: stopProgressBar</strong>)
</code></pre></div>      </div>
        </div>
    </li>
    <li>
        <p id="begin-factory-name-with-make"><strong>Begin names of factory methods with “<code class="language-plaintext highlighter-rouge">make</code>”,</strong>
e.g. <code class="language-plaintext highlighter-rouge">x.makeIterator()</code>.</p>
    </li>
    <li>
        <p id="init-factory-phrase-ends-with-basename">The first argument to <strong>initializer and
<a href="https://en.wikipedia.org/wiki/Factory_method_pattern">factory methods</a> calls</strong>
should not form a phrase starting with the base name,
e.g. <code class="language-plaintext highlighter-rouge">x.makeWidget(cogCount: 47)</code></p>

        <div class="more">
            <p>For example, the first arguments to these calls do not read as part of the same
phrase as the base name:</p>

            <div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let foreground = <strong>Color</strong>(red: 32, green: 64, blue: 128)
let newPart = <strong>factory.makeWidget</strong>(gears: 42, spindles: 14)
let ref = <strong>Link</strong>(target: destination)
</code></pre></div>      </div>

            <p>In the following, the API author has tried to create grammatical
continuity with the first argument.</p>

            <div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let foreground = <strong>Color(havingRGBValuesRed: 32, green: 64, andBlue: 128)</strong>
let newPart = <strong>factory.makeWidget(havingGearCount: 42, andSpindleCount: 14)</strong>
let ref = <strong>Link(to: destination)</strong>
</code></pre></div>      </div>

            <p>In practice, this guideline along with those for
<a href="#argument-labels">argument labels</a> means the first argument will
have a label unless the call is performing a
<a href="#type-conversion">value preserving type conversion</a>.</p>

            <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let rgbForeground = RGBColor(cmykForeground)
</code></pre></div>      </div>
        </div>
    </li>
    <li>
        <p id="name-according-to-side-effects"><strong>Name functions and methods according to their side-effects</strong></p>

        <ul>
            <li>
                <p>Those without side-effects should read as noun phrases,
e.g. <code class="language-plaintext highlighter-rouge">x.distance(to: y)</code>, <code class="language-plaintext highlighter-rouge">i.successor()</code>.</p>
            </li>
            <li>
                <p>Those with side-effects should read as imperative verb phrases,
e.g., <code class="language-plaintext highlighter-rouge">print(x)</code>, <code class="language-plaintext highlighter-rouge">x.sort()</code>, <code class="language-plaintext highlighter-rouge">x.append(y)</code>.</p>
            </li>
            <li>
                <p><strong>Name Mutating/nonmutating method pairs</strong> consistently.
A mutating method will often have a nonmutating variant with
similar semantics, but that returns a new value rather than
updating an instance in-place.</p>

                <ul>
                    <li>
                        <p>When the operation is <strong>naturally described by a verb</strong>, use the
verb’s imperative for the mutating method and apply the “ed” or
“ing” suffix to name its nonmutating counterpart.</p>

                        <table>
                            <thead>
                                <tr>
                                    <th>Mutating</th>
                                    <th>Nonmutating</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td><code class="language-plaintext highlighter-rouge">x.sort()</code></td>
                                    <td><code class="language-plaintext highlighter-rouge">z = x.sorted()</code></td>
                                </tr>
                                <tr>
                                    <td><code class="language-plaintext highlighter-rouge">x.append(y)</code></td>
                                    <td><code class="language-plaintext highlighter-rouge">z = x.appending(y)</code></td>
                                </tr>
                            </tbody>
                        </table>

                        <div class="more">

                            <ul>
                                <li>
                                    <p>Prefer to name the nonmutating variant using the verb’s past
<a href="https://en.wikipedia.org/wiki/Participle">participle</a> (usually
appending “ed”):</p>

                                    <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/// Reverses `self` in-place.
mutating func reverse()

/// Returns a reversed copy of `self`.
func revers<strong>ed</strong>() -&gt; Self
...
x.reverse()
let y = x.reversed()
</code></pre></div>                  </div>
                                </li>
                                <li>
                                    <p>When adding “ed” is not grammatical because the verb has a direct
object, name the nonmutating variant using the verb’s present
<a href="https://en.wikipedia.org/wiki/Participle">participle</a>, by
appending “ing.”</p>

                                    <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/// Strips all the newlines from `self`
mutating func stripNewlines()

/// Returns a copy of `self` with all the newlines stripped.
func strip<strong>ping</strong>Newlines() -&gt; String
...
s.stripNewlines()
let oneLine = t.strippingNewlines()
</code></pre></div>                  </div>
                                </li>
                            </ul>

                        </div>
                    </li>
                    <li>
                        <p>When the operation is <strong>naturally described by a noun</strong>, use the
noun for the nonmutating method and apply the “form” prefix to
name its mutating counterpart.</p>

                        <table>
                            <thead>
                                <tr>
                                    <th>Nonmutating</th>
                                    <th>Mutating</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td><code class="language-plaintext highlighter-rouge">x = y.union(z)</code></td>
                                    <td><code class="language-plaintext highlighter-rouge">y.formUnion(z)</code></td>
                                </tr>
                                <tr>
                                    <td><code class="language-plaintext highlighter-rouge">j = c.successor(i)</code></td>
                                    <td><code class="language-plaintext highlighter-rouge">c.formSuccessor(&amp;i)</code></td>
                                </tr>
                            </tbody>
                        </table>
                    </li>
                </ul>
            </li>
        </ul>
    </li>
    <li>
        <p id="boolean-assertions"><strong>Uses of Boolean methods and properties should read as assertions
about the receiver</strong> when the use is nonmutating, e.g. <code class="language-plaintext highlighter-rouge">x.isEmpty</code>,
<code class="language-plaintext highlighter-rouge">line1.intersects(line2)</code>.</p>
    </li>
    <li>
        <p id="protocols-describing-what-is-should-read-as-nouns"><strong>Protocols that describe <em>what something is</em> should read as
nouns</strong> (e.g. <code class="language-plaintext highlighter-rouge">Collection</code>).</p>
    </li>
    <li>
        <p id="protocols-describing-capability-should-use-suffixes"><strong>Protocols that describe a <em>capability</em>
should be named using the suffixes <code class="language-plaintext highlighter-rouge">able</code>, <code class="language-plaintext highlighter-rouge">ible</code>, or <code class="language-plaintext highlighter-rouge">ing</code></strong>
(e.g. <code class="language-plaintext highlighter-rouge">Equatable</code>, <code class="language-plaintext highlighter-rouge">ProgressReporting</code>).</p>
    </li>
    <li>
        <p id="name-of-others-should-read-as-nouns">The names of other <strong>types, properties, variables, and constants
should read as nouns.</strong></p>
    </li>
</ul>

<h3 id="use-terminology-well">Use Terminology Well</h3>

<dl>
    <dt><strong>Term of Art</strong></dt>
    <dd><em>noun</em> - a word or phrase that has a precise, specialized meaning
within a particular field or profession.</dd>
</dl>

<ul>
    <li>
        <p id="avoid-obscure-terms"><strong>Avoid obscure terms</strong> if a more common word conveys meaning just
as well.  Don’t say “epidermis” if “skin” will serve your purpose.
Terms of art are an essential communication tool, but should only be
used to capture crucial meaning that would otherwise be lost.</p>
    </li>
    <li>
        <p id="stick-to-established-meaning"><strong>Stick to the established meaning</strong> if you do use a term of art.</p>

        <div class="more">
            <p>The only reason to use a technical term rather than a more common
word is that it <em>precisely</em> expresses something that would
otherwise be ambiguous or unclear.  Therefore, an API should use
the term strictly in accordance with its accepted meaning.</p>

            <ul>
                <li>
                    <p id="do-not-surprise-an-expert"><strong>Don’t surprise an expert</strong>: anyone already familiar with the term
will be surprised and probably angered if we appear to have
invented a new meaning for it.</p>
                </li>
                <li>
                    <p id="do-not-confuse-a-beginner"><strong>Don’t confuse a beginner</strong>: anyone trying to learn the term is
likely to do a web search and find its traditional meaning.</p>
                </li>
            </ul>
        </div>
    </li>
    <li>
        <p id="avoid-abbreviations"><strong>Avoid abbreviations.</strong> Abbreviations, especially non-standard
ones, are effectively terms-of-art, because understanding depends on
correctly translating them into their non-abbreviated forms.</p>

        <blockquote>
            <p>The intended meaning for any abbreviation you use should be
easily found by a web search.</p>
        </blockquote>
    </li>
    <li>
        <p id="embrace-precedent"><strong>Embrace precedent.</strong> Don’t optimize terms for the total beginner
at the expense of conformance to existing culture.</p>

        <div class="more">
            <p>It is better to name a contiguous data structure <code class="language-plaintext highlighter-rouge">Array</code> than to
use a simplified term such as <code class="language-plaintext highlighter-rouge">List</code>, even though a beginner
might grasp the meaning of <code class="language-plaintext highlighter-rouge">List</code> more easily.  Arrays are
fundamental in modern computing, so every programmer knows—or
will soon learn—what an array is.  Use a term that most
programmers are familiar with, and their web searches and
questions will be rewarded.</p>

            <p>Within a particular programming <em>domain</em>, such as mathematics, a
widely precedented term such as <code class="language-plaintext highlighter-rouge">sin(x)</code> is preferable to an
explanatory phrase such as
<code class="language-plaintext highlighter-rouge">verticalPositionOnUnitCircleAtOriginOfEndOfRadiusWithAngle(x)</code>.
Note that in this case, precedent outweighs the guideline to
avoid abbreviations: although the complete word is <code class="language-plaintext highlighter-rouge">sine</code>,
“sin(<em>x</em>)” has been in common use among programmers for decades,
and among mathematicians for centuries.</p>
        </div>
    </li>
</ul>

<h2 id="conventions">Conventions</h2>

<h3 id="general-conventions">General Conventions</h3>

<ul>
    <li>
        <p id="document-computed-property-complexity"><strong>Document the complexity of any computed property that is not
O(1).</strong>  People often assume that property access involves no
significant computation, because they have stored properties as a
mental model. Be sure to alert them when that assumption may be
violated.</p>
    </li>
    <li>
        <p id="prefer-method-and-properties-to-functions"><strong>Prefer methods and properties to free functions.</strong>  Free functions
are used only in special cases:</p>

        <div class="more">

            <ol>
                <li>
                    <p>When there’s no obvious <code class="language-plaintext highlighter-rouge">self</code>:</p>

                    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>min(x, y, z)
</code></pre></div>          </div>
                </li>
                <li>
                    <p>When the function is an unconstrained generic:</p>

                    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>print(x)
</code></pre></div>          </div>
                </li>
                <li>
                    <p>When function syntax is part of the established domain notation:</p>

                    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sin(x)
</code></pre></div>          </div>
                </li>
            </ol>

        </div>
    </li>
    <li>
        <p id="follow-case-conventions"><strong>Follow case conventions.</strong> Names of types and protocols are
<code class="language-plaintext highlighter-rouge">UpperCamelCase</code>.  Everything else is <code class="language-plaintext highlighter-rouge">lowerCamelCase</code>.</p>

        <div class="more">

            <p><a href="https://en.wikipedia.org/wiki/Acronym">Acronyms and initialisms</a>
that commonly appear as all upper case in American English should be
uniformly up- or down-cased according to case conventions:</p>

            <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var <strong>utf8</strong>Bytes: [<strong>UTF8</strong>.CodeUnit]
var isRepresentableAs<strong>ASCII</strong> = true
var user<strong>SMTP</strong>Server: Secure<strong>SMTP</strong>Server
</code></pre></div>      </div>

            <p>Other acronyms should be treated as ordinary words:</p>

            <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var <strong>radar</strong>Detector: <strong>Radar</strong>Scanner
var enjoys<strong>Scuba</strong>Diving = true
</code></pre></div>      </div>
        </div>
    </li>
    <li>
        <p id="similar-methods-can-share-a-base-name"><strong>Methods can share a base name</strong> when they share the same basic
meaning or when they operate in distinct domains.</p>

        <div class="more">
            <p>For example, the following is encouraged, since the methods do essentially
the same things:</p>

            <div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code>extension Shape {
    /// Returns `true` if `other` is within the area of `self`;
    /// otherwise, `false`.
    func <strong>contains</strong>(_ other: <strong>Point</strong>) -&gt; Bool { ... }

    /// Returns `true` if `other` is entirely within the area of `self`;
    /// otherwise, `false`.
    func <strong>contains</strong>(_ other: <strong>Shape</strong>) -&gt; Bool { ... }

    /// Returns `true` if `other` is within the area of `self`;
    /// otherwise, `false`.
    func <strong>contains</strong>(_ other: <strong>LineSegment</strong>) -&gt; Bool { ... }
}
</code></pre></div>      </div>

            <p>And since geometric types and collections are separate domains,
this is also fine in the same program:</p>

            <div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code>extension Collection where Element : Equatable {
    /// Returns `true` if `self` contains an element equal to
    /// `sought`; otherwise, `false`.
    func <strong>contains</strong>(_ sought: Element) -&gt; Bool { ... }
}
</code></pre></div>      </div>

            <p>However, these <code class="language-plaintext highlighter-rouge">index</code> methods have different semantics, and should
have been named differently:</p>

            <div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code>extension Database {
    /// Rebuilds the database's search index
    func <strong>index</strong>() { ... }

    /// Returns the `n`th row in the given table.
    func <strong>index</strong>(_ n: Int, inTable: TableID) -&gt; TableRow { ... }
}
</code></pre></div>      </div>

            <p>Lastly, avoid “overloading on return type” because it causes
ambiguities in the presence of type inference.</p>

            <div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code>extension Box {
    /// Returns the `Int` stored in `self`, if any, and
    /// `nil` otherwise.
    func <strong>value</strong>() -&gt; Int? { ... }

    /// Returns the `String` stored in `self`, if any, and
    /// `nil` otherwise.
    func <strong>value</strong>() -&gt; String? { ... }
}
</code></pre></div>      </div>

        </div>
    </li>
</ul>

<h3 id="parameter-names">Parameters</h3>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code>func move(from <strong>start</strong>: Point, to <strong>end</strong>: Point)
</code></pre></div></div>

<ul>
    <li>
        <p id="choose-parameter-names-to-serve-doc"><strong>Choose parameter names to serve documentation</strong>. Even though
parameter names do not appear at a function or method’s point of
use, they play an important explanatory role.</p>

        <div class="more">
            <p>Choose these names to make documentation easy to read.  For example,
these names make documentation read naturally:</p>

            <div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/// Return an `Array` containing the elements of `self`
/// that satisfy `<strong>predicate</strong>`.
func filter(_ <strong>predicate</strong>: (Element) -&gt; Bool) -&gt; [Generator.Element]

/// Replace the given `<strong>subRange</strong>` of elements with `<strong>newElements</strong>`.
mutating func replaceRange(_ <strong>subRange</strong>: Range<index>, with <strong>newElements</strong>: [E])
</index></code></pre></div>      </div>

            <p>These, however, make the documentation awkward and ungrammatical:</p>

            <div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/// Return an `Array` containing the elements of `self`
/// that satisfy `<strong>includedInResult</strong>`.
func filter(_ <strong>includedInResult</strong>: (Element) -&gt; Bool) -&gt; [Generator.Element]

/// Replace the <strong>range of elements indicated by `r`</strong> with
/// the contents of `<strong>with</strong>`.
mutating func replaceRange(_ <strong>r</strong>: Range<index>, <strong>with</strong>: [E])
</index></code></pre></div>      </div>

        </div>
    </li>
    <li>
        <p id="take-advantage-of-defaulted-parameters"><strong>Take advantage of defaulted parameters</strong> when it simplifies common
uses.  Any parameter with a single commonly-used value is a
candidate for a default.</p>

        <div class="more">
            <p>Default arguments improve readability by
hiding irrelevant information.  For example:</p>

            <div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let order = lastName.compare(
    royalFamilyName<strong>, options: [], range: nil, locale: nil</strong>)
</code></pre></div>      </div>

            <p>can become the much simpler:</p>

            <div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let order = lastName.<strong>compare(royalFamilyName)</strong>
</code></pre></div>      </div>

            <p>Default arguments are generally preferable to the use of method
families, because they impose a lower cognitive burden on anyone
trying to understand the API.</p>

            <div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code>extension String {
    /// <em>...description...</em>
    public func compare(
         _ other: String, options: CompareOptions <strong>= []</strong>,
         range: Range<index>? <strong>= nil</strong>, locale: Locale? <strong>= nil</strong>
    ) -&gt; Ordering
}
</index></code></pre></div>      </div>

            <p>The above may not be simple, but it is much simpler than:</p>

            <div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code>extension String {
    /// <em>...description 1...</em>
    public func <strong>compare</strong>(_ other: String) -&gt; Ordering
    /// <em>...description 2...</em>
    public func <strong>compare</strong>(_ other: String, options: CompareOptions) -&gt; Ordering
    /// <em>...description 3...</em>
    public func <strong>compare</strong>(
         _ other: String, options: CompareOptions, range: Range<index>) -&gt; Ordering
    /// <em>...description 4...</em>
    public func <strong>compare</strong>(
         _ other: String, options: StringCompareOptions,
         range: Range<index>, locale: Locale) -&gt; Ordering
}
</index></index></code></pre></div>      </div>

            <p>Every member of a method family needs to be separately documented
and understood by users. To decide among them, a user needs to
understand all of them, and occasional surprising relationships—for
example, <code class="language-plaintext highlighter-rouge">foo(bar: nil)</code> and <code class="language-plaintext highlighter-rouge">foo()</code> aren’t always synonyms—make
this a tedious process of ferreting out minor differences in
mostly identical documentation.  Using a single method with
defaults provides a vastly superior programmer experience.</p>
        </div>
    </li>
    <li>
        <p id="parameter-with-defaults-towards-the-end"><strong>Prefer to locate parameters with defaults toward the end</strong> of the
parameter list.  Parameters without defaults are usually more
essential to the semantics of a method, and provide a stable initial
pattern of use where methods are invoked.</p>
    </li>
    <li>
        <p><strong>If your API will run in production, prefer <code class="language-plaintext highlighter-rouge">#fileID</code></strong> over alternatives.
<code class="language-plaintext highlighter-rouge">#fileID</code> saves space and protects developers’ privacy. Use <code class="language-plaintext highlighter-rouge">#filePath</code> in
APIs that are never run by end users (such as test helpers and scripts) if
the full path will simplify development workflows or be used for file I/O.
Use <code class="language-plaintext highlighter-rouge">#file</code> to preserve source compatibility with Swift 5.2 or earlier.</p>
    </li>
</ul>

<h3 id="argument-labels">Argument Labels</h3>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code>func move(<strong>from</strong> start: Point, <strong>to</strong> end: Point)
x.move(<strong>from:</strong> x, <strong>to:</strong> y)
</code></pre></div></div>

<ul>
    <li>
        <p id="no-labels-for-indistinguishable-arguments"><strong>Omit all labels when arguments can’t be usefully distinguished</strong>,
e.g. <code class="language-plaintext highlighter-rouge">min(number1, number2)</code>, <code class="language-plaintext highlighter-rouge">zip(sequence1, sequence2)</code>.</p>
    </li>
    <li>
        <p id="type-conversion"><strong>In initializers that perform value preserving type conversions, omit the
first argument label</strong>, e.g. <code class="language-plaintext highlighter-rouge">Int64(someUInt32)</code></p>

        <div class="more">
            <p>The first argument should always be the source of the conversion.</p>

            <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>extension String {
    // Convert `x` into its textual representation in the given radix
    init(<strong>_</strong> x: BigInt, radix: Int = 10)   <span class="commentary">← Note the initial underscore</span>
}

text = "The value is: "
text += <strong>String(veryLargeNumber)</strong>
text += " and in hexadecimal, it's"
text += <strong>String(veryLargeNumber, radix: 16)</strong>
</code></pre></div>      </div>

            <p>In “narrowing” type conversions, though, a label that describes
the narrowing is recommended.</p>

            <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code>extension UInt32 {
    /// Creates an instance having the specified `value`.
    init(<strong>_</strong> value: Int16)            <span class="commentary">← Widening, so no label</span>
    /// Creates an instance having the lowest 32 bits of `source`.
    init(<strong>truncating</strong> source: UInt64)
    /// Creates an instance having the nearest representable
    /// approximation of `valueToApproximate`.
    init(<strong>saturating</strong> valueToApproximate: UInt64)
}
</code></pre></div>      </div>

            <blockquote>
                <p>A value preserving type conversion is a
<a href="https://en.wikipedia.org/wiki/Monomorphism">monomorphism</a>, i.e.
every difference in the
value of the source results in a difference in the value of the
result.
For example, conversion from <code class="language-plaintext highlighter-rouge">Int8</code> to <code class="language-plaintext highlighter-rouge">Int64</code> is value
preserving because every distinct <code class="language-plaintext highlighter-rouge">Int8</code> value is converted to a
distinct <code class="language-plaintext highlighter-rouge">Int64</code> value.  Conversion in the other direction, however,
cannot be value preserving: <code class="language-plaintext highlighter-rouge">Int64</code> has more possible values than
can be represented in an <code class="language-plaintext highlighter-rouge">Int8</code>.</p>

                <p>Note: the ability to retrieve the original value has no bearing
on whether a conversion is value preserving.</p>
            </blockquote>

        </div>
    </li>
    <li>
        <p id="give-prepositional-phrase-argument-label"><strong>When the first argument forms part of a
<a href="https://en.wikipedia.org/wiki/Adpositional_phrase#Prepositional_phrases">prepositional phrase</a>,
give it an argument label</strong>.  The argument label should normally begin at the
<a href="https://en.wikipedia.org/wiki/Preposition">preposition</a>,
e.g. <code class="language-plaintext highlighter-rouge">x.removeBoxes(havingLength: 12)</code>.</p>

        <div class="more">
            <p>An exception arises when the first two arguments represent parts of
a single abstraction.</p>

            <div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code>a.move(<strong>toX:</strong> b, <strong>y:</strong> c)
a.fade(<strong>fromRed:</strong> b, <strong>green:</strong> c, <strong>blue:</strong> d)
</code></pre></div>      </div>

            <p>In such cases, begin the argument label <em>after</em> the preposition, to
keep the abstraction clear.</p>

            <div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code>a.moveTo(<strong>x:</strong> b, <strong>y:</strong> c)
a.fadeFrom(<strong>red:</strong> b, <strong>green:</strong> c, <strong>blue:</strong> d)
</code></pre></div>      </div>
        </div>
    </li>
    <li>
        <p id="omit-first-argument-if-partial-phrase"><strong>Otherwise, if the first argument forms part of a grammatical
phrase, omit its label</strong>, appending any preceding words to the base
name, e.g. <code class="language-plaintext highlighter-rouge">x.addSubview(y)</code></p>

        <div class="more">
            <p>This guideline implies that if the first argument <em>doesn’t</em> form
part of a grammatical phrase, it should have a label.</p>

            <div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code>view.dismiss(<strong>animated:</strong> false)
let text = words.split(<strong>maxSplits:</strong> 12)
let studentsByName = students.sorted(<strong>isOrderedBefore:</strong> Student.namePrecedes)
</code></pre></div>      </div>

            <p>Note that it’s important that the phrase convey the correct meaning.
The following would be grammatical but would express the wrong
thing.</p>

            <div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code>view.dismiss(false)   <span class="commentary">Don't dismiss? Dismiss a Bool?</span>
words.split(12)       <span class="commentary">Split the number 12?</span>
</code></pre></div>      </div>

            <p>Note also that arguments with default values can be omitted, and
in that case do not form part of a grammatical phrase, so they
should always have labels.</p>
        </div>
    </li>
    <li>
        <p><strong>Label all other arguments</strong>.</p>
    </li>
</ul>

<h2 id="special-instructions">Special Instructions</h2>

<ul>
    <li>
        <p id="label-closure-parameters"><strong>Label tuple members and name closure parameters</strong> where they
appear in your API.</p>

        <div class="more">
            <p>These names have
explanatory power, can be referenced from documentation comments,
and provide expressive access to tuple members.</p>

            <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/// Ensure that we hold uniquely-referenced storage for at least
/// `requestedCapacity` elements.
///
/// If more storage is needed, `allocate` is called with
/// <strong>`byteCount`</strong> equal to the number of maximally-aligned
/// bytes to allocate.
///
/// - Returns:
///   - <strong>reallocated</strong>: `true` if a new block of memory
///     was allocated; otherwise, `false`.
///   - <strong>capacityChanged</strong>: `true` if `capacity` was updated;
///     otherwise, `false`.
mutating func ensureUniqueStorage(
    minimumCapacity requestedCapacity: Int,
    allocate: (_ <strong>byteCount</strong>: Int) -&gt; UnsafePointer<void>
) -&gt; (<strong>reallocated:</strong> Bool, <strong>capacityChanged:</strong> Bool)
</void></code></pre></div>      </div>

            <p>Names used for closure parameters should be chosen like
<a href="#parameter-names">parameter names</a> for top-level functions. Labels for
closure arguments that appear at the call site are not supported.</p>
        </div>
    </li>
    <li>
        <p id="unconstrained-polymorphism"><strong>Take extra care with unconstrained polymorphism</strong> (e.g. <code class="language-plaintext highlighter-rouge">Any</code>,
<code class="language-plaintext highlighter-rouge">AnyObject</code>, and unconstrained generic parameters) to avoid
ambiguities in overload sets.</p>

        <div class="more">
            <p>For example, consider this overload set:</p>

            <div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code>struct Array<element> {
    /// Inserts `newElement` at `self.endIndex`.
    public mutating func append(_ newElement: Element)

    /// Inserts the contents of `newElements`, in order, at
    /// `self.endIndex`.
    public mutating func append<s: sequencetype="">(_ newElements: S)
        where S.Generator.Element == Element
}
</s:></element></code></pre></div>      </div>

            <p>These methods form a semantic family, and the argument types
appear at first to be sharply distinct.  However, when <code class="language-plaintext highlighter-rouge">Element</code>
is <code class="language-plaintext highlighter-rouge">Any</code>, a single element can have the same type as a sequence of
elements.</p>

            <div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var values: [Any] = [1, "a"]
values.append([2, 3, 4]) // [1, "a", [2, 3, 4]] or [1, "a", 2, 3, 4]?
</code></pre></div>      </div>

            <p>To eliminate the ambiguity, name the second overload more
explicitly.</p>

            <div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code>struct Array {
    /// Inserts `newElement` at `self.endIndex`.
    public mutating func append(_ newElement: Element)

    /// Inserts the contents of `newElements`, in order, at
    /// `self.endIndex`.
    public mutating func append<s: sequencetype="">(<strong>contentsOf</strong> newElements: S)
        where S.Generator.Element == Element
}
</s:></code></pre></div>      </div>

            <p>Notice how the new name better matches the documentation comment.
In this case, the act of writing the documentation comment
actually brought the issue to the API author’s attention.</p>
        </div>
    </li>
</ul>

<script>
var elements = document.querySelectorAll("pre code");
for (i in elements) {
        var element = elements[i];
        if (element.textContent) {
                element.innerHTML = element.textContent
                        .replace(/\*\*([^\*]+)\*\*/g, "<strong>$1</strong>")
                        .replace(/\*([^\*]+)\*/g, "<em>$1</em>");
        }
}
function show_or_hide_all(){
        var checkboxes = document.getElementsByClassName('detail');
        var button = document.getElementById('toggle');

        if(button.value == 'Expand all details now'){
                for (var i in checkboxes){
                        checkboxes[i].checked = 'FALSE';
                }
                button.value = 'Collapse all details now'
        }else{
                for (var i in checkboxes){
                        checkboxes[i].checked = '';
                }
                button.value = 'Expand all details now';
        }
}
if (location.search.match(/[?&]expand=true\b/)) {
        show_or_hide_all();
}
</script>


    
</article>

</main>


<script src="js/application.js"></script>


</body></html>